<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake — Forest Edition</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #0a1410;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #c3e68c;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }
    #game-container {
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    #game-canvas {
      display: block;
      background: #0a1410;
    }
    .hint {
      margin-top: 0.75rem;
      font-size: 0.85rem;
      color: #6b8a6b;
    }
  </style>
</head>
<body>
  <h1>Snake — Forest Edition</h1>
  <div id="game-container">
    <canvas id="game-canvas" width="800" height="600"></canvas>
  </div>
  <p class="hint">↑↓←→ or W A S D to move</p>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');

    const W = 800, H = 600;
    const CELL = 20;
    const COLS = W / CELL, ROWS = H / CELL;
    const BASE_SPEED = 120;

    const COLORS = {
      forestTop: '#061a14',
      forestMid: '#0a2d1c',
      forestBottom: '#241a12',
      treeDark: '#091910',
      treeLeaves: '#144623',
      mist: 'rgba(78, 160, 120, 0.25)',
      snakeHead: '#aaf078',
      snakeBody: '#5abe5a',
      snakeBelly: '#286e3c',
      snakeOutline: '#0f2814',
      appleRed: '#d73c3c',
      appleHighlight: '#fad2d2',
      appleLeaf: '#28823c',
      appleStem: '#5a371e',
      grid: '#142d1e',
      hudBg: '#08100c',
      hudLine: '#193723',
      accent: '#c3e68c',
      white: '#ffffff',
      gray: '#6b8a6b',
    };

    let state = 'menu';
    let snake = [], direction = [1, 0], growPending = 0;
    let food = { x: 0, y: 0 };
    let score = 0, best = 0;
    let speed = BASE_SPEED;
    let selected = 1;
    let lastMove = 0;
    let tick = 0;

    const DIFFICULTIES = [
      { name: 'Easy', mult: 0.8 },
      { name: 'Normal', mult: 1 },
      { name: 'Hard', mult: 1.3 },
    ];

    function randomFood() {
      const free = [];
      const set = new Set(snake.map(s => `${s.x},${s.y}`));
      for (let x = 0; x < COLS; x++)
        for (let y = 0; y < ROWS; y++)
          if (!set.has(`${x},${y}`)) free.push({ x, y });
      const p = free[Math.floor(Math.random() * free.length)];
      return p || { x: 0, y: 0 };
    }

    function resetGame() {
      snake = [{ x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2) }];
      direction = [1, 0];
      growPending = 0;
      food = randomFood();
      score = 0;
    }

    function drawForestBg() {
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, COLORS.forestTop);
      g.addColorStop(0.45, COLORS.forestMid);
      g.addColorStop(1, COLORS.forestBottom);
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      const sway = Math.sin(tick * 0.01) * 4;
      for (let x = -60; x < W + 60; x += 120) {
        const i = Math.floor((x + 60) / 120);
        const bx = x + sway * (1 + (i % 3));
        ctx.fillStyle = COLORS.treeDark;
        ctx.fillRect(bx, H - 200, 22, 160);
        ctx.fillStyle = COLORS.treeLeaves;
        ctx.beginPath();
        ctx.moveTo(bx + 11, H - 220);
        ctx.lineTo(bx - 25, H - 40);
        ctx.lineTo(bx + 47, H - 40);
        ctx.closePath();
        ctx.fill();
      }

      ctx.fillStyle = COLORS.mist;
      ctx.fillRect(0, H - 140, W, 120);
    }

    function drawGrid() {
      ctx.strokeStyle = COLORS.grid;
      ctx.lineWidth = 1;
      for (let x = 0; x <= W; x += CELL) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = 0; y <= H; y += CELL) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }
    }

    function drawSnake() {
      for (let i = 0; i < snake.length; i++) {
        const s = snake[i];
        const x = s.x * CELL, y = s.y * CELL;
        const isHead = i === 0;

        ctx.fillStyle = COLORS.snakeOutline;
        roundRect(x, y, CELL, CELL, 8);
        ctx.fill();

        ctx.fillStyle = COLORS.snakeBody;
        roundRect(x + 3, y + 3, CELL - 6, CELL - 6, 7);
        ctx.fill();

        ctx.fillStyle = COLORS.snakeBelly;
        roundRect(x + 3, y + CELL / 2, CELL - 6, CELL / 2 - 3, 7);
        ctx.fill();

        if (isHead) {
          ctx.fillStyle = COLORS.snakeHead;
          roundRect(x + 1, y + 1, CELL - 2, CELL - 2, 9);
          ctx.fill();

          const [dx, dy] = direction;
          let e1, e2;
          if (dx === 1) {
            e1 = [x + CELL - 8, y + 8];
            e2 = [x + CELL - 8, y + CELL - 8];
          } else if (dx === -1) {
            e1 = [x + 8, y + 8];
            e2 = [x + 8, y + CELL - 8];
          } else if (dy === -1) {
            e1 = [x + 8, y + 8];
            e2 = [x + CELL - 8, y + 8];
          } else {
            e1 = [x + 8, y + CELL - 8];
            e2 = [x + CELL - 8, y + CELL - 8];
          }
          ctx.fillStyle = COLORS.white;
          ctx.beginPath();
          ctx.arc(e1[0], e1[1], 3, 0, Math.PI * 2);
          ctx.arc(e2[0], e2[1], 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#111';
          ctx.beginPath();
          ctx.arc(e1[0], e1[1], 2, 0, Math.PI * 2);
          ctx.arc(e2[0], e2[1], 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function roundRect(x, y, w, h, r) {
      r = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function drawFood() {
      const cx = food.x * CELL + CELL / 2;
      const cy = food.y * CELL + CELL / 2 + 2;
      const r = CELL / 2 - 3;

      ctx.fillStyle = COLORS.appleRed;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = COLORS.appleHighlight;
      ctx.beginPath();
      ctx.arc(cx - r / 3, cy - r / 3, Math.max(1, r / 4), 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = COLORS.appleStem;
      ctx.fillRect(cx - 1, cy - r - 4, 3, 6);

      ctx.fillStyle = COLORS.appleLeaf;
      ctx.beginPath();
      ctx.moveTo(cx + 2, cy - r);
      ctx.lineTo(cx + 10, cy - r - 6);
      ctx.lineTo(cx + 6, cy - r + 2);
      ctx.closePath();
      ctx.fill();
    }

    function drawHUD() {
      ctx.fillStyle = COLORS.hudBg;
      ctx.fillRect(0, 0, W, 32);
      ctx.strokeStyle = COLORS.hudLine;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, 32);
      ctx.lineTo(W, 32);
      ctx.stroke();

      ctx.font = '18px Consolas, monospace';
      ctx.fillStyle = COLORS.white;
      ctx.fillText(`Score: ${score}`, 12, 22);
      ctx.fillStyle = COLORS.accent;
      ctx.textAlign = 'right';
      ctx.fillText(`Best: ${best}`, W - 12, 22);
      ctx.textAlign = 'left';
    }

    function drawMenu() {
      drawForestBg();
      tick++;

      ctx.font = 'bold 64px Consolas, monospace';
      ctx.fillStyle = COLORS.white;
      ctx.textAlign = 'center';
      ctx.fillText('SNAKE', W / 2, H / 2 - 140);

      ctx.font = '18px Consolas, monospace';
      ctx.fillStyle = COLORS.accent;
      ctx.fillText('↑/↓ to choose difficulty, ENTER to start', W / 2, H / 2 - 90);

      ctx.font = '28px Consolas, monospace';
      DIFFICULTIES.forEach((d, i) => {
        const sel = i === selected;
        ctx.fillStyle = sel ? COLORS.accent : COLORS.white;
        ctx.fillText((sel ? '▶ ' : '   ') + d.name, W / 2, H / 2 - 10 + i * 40);
      });

      ctx.font = '16px Consolas, monospace';
      ctx.fillStyle = COLORS.gray;
      ctx.textAlign = 'right';
      ctx.fillText('ESC to quit', W - 10, H - 10);
      ctx.textAlign = 'left';
    }

    function drawGameOver() {
      drawForestBg();
      tick++;

      ctx.font = 'bold 36px Consolas, monospace';
      ctx.fillStyle = COLORS.white;
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', W / 2, H / 2 - 60);

      ctx.font = '18px Consolas, monospace';
      ctx.fillText(`Score: ${score}`, W / 2, H / 2);
      ctx.fillStyle = COLORS.accent;
      ctx.fillText(`Best: ${best}`, W / 2, H / 2 + 30);
      ctx.fillStyle = COLORS.white;
      ctx.fillText('ENTER: play again   M: menu   ESC: quit', W / 2, H / 2 + 80);
      ctx.textAlign = 'left';
    }

    function moveSnake() {
      const h = snake[0];
      const nx = (h.x + direction[0] + COLS) % COLS;
      const ny = (h.y + direction[1] + ROWS) % ROWS;

      for (let i = 1; i < snake.length; i++)
        if (snake[i].x === nx && snake[i].y === ny) return false;

      snake.unshift({ x: nx, y: ny });
      if (growPending > 0) growPending--;
      else snake.pop();
      return true;
    }

    function gameLoop(now) {
      tick++;
      if (state === 'menu') {
        drawMenu();
        requestAnimationFrame(gameLoop);
        return;
      }
      if (state === 'gameover') {
        drawGameOver();
        requestAnimationFrame(gameLoop);
        return;
      }

      if (now - lastMove >= speed) {
        lastMove = now;
        if (!moveSnake()) {
          if (score > best) best = score;
          state = 'gameover';
          drawGameOver();
          requestAnimationFrame(gameLoop);
          return;
        }
        if (snake[0].x === food.x && snake[0].y === food.y) {
          score++;
          growPending++;
          food = randomFood();
        }
      }

      drawForestBg();
      drawGrid();
      drawSnake();
      drawFood();
      drawHUD();
      requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', (e) => {
      if (state === 'menu') {
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
          selected = (selected - 1 + DIFFICULTIES.length) % DIFFICULTIES.length;
          e.preventDefault();
        } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
          selected = (selected + 1) % DIFFICULTIES.length;
          e.preventDefault();
        } else if (e.key === 'Enter' || e.key === ' ') {
          speed = Math.max(50, BASE_SPEED / DIFFICULTIES[selected].mult);
          resetGame();
          state = 'play';
          lastMove = performance.now();
          e.preventDefault();
        } else if (e.key === 'Escape') {
          // Could close window; for web we ignore
        }
        return;
      }
      if (state === 'gameover') {
        if (e.key === 'Enter') {
          resetGame();
          state = 'play';
          lastMove = performance.now();
          e.preventDefault();
        } else if (e.key === 'm' || e.key === 'M') {
          state = 'menu';
          e.preventDefault();
        } else if (e.key === 'Escape') {
          state = 'menu';
          e.preventDefault();
        }
        return;
      }
      if (state === 'play') {
        const opp = [-direction[0], -direction[1]];
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
          if (opp[1] !== -1) direction = [0, -1];
          e.preventDefault();
        } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
          if (opp[1] !== 1) direction = [0, 1];
          e.preventDefault();
        } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
          if (opp[0] !== -1) direction = [-1, 0];
          e.preventDefault();
        } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
          if (opp[0] !== 1) direction = [1, 0];
          e.preventDefault();
        }
      }
    });

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
